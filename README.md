# 简介
当前项目只是记录个人leecode的刷题代码情况

# 算法复杂度
## 时间复杂度
执行一行代码，执行时间为t
示例一：
```java
 int cal(int n){
    int sum=0;
    for(int i=1;i<=n;++i){
        sum=sum+1;
        }
    return sum;
}
```
执行时间为`t+n*t`;即`T(n)= t+n*t`;
示例二：
```java
 int cal2(int n){
    int sum=0;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
        sum=sum+i*j;
        }
        }
    return sum;
}
```
执行时间为 `t+t*n+t*n^2`;即`T(n)= t+t*n+t*n^2`;
得到结论：
`T(n)=O(f(n))`;`f(n)`为多项式。
### 时间复杂度分析
1. 方式一：只关注循环次数最多的一段代码
2. 总复杂度等于最高阶项的复杂度
3. 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

推导大O阶：
1、用常数1取代运行时间中的所有加法常数。
2、在修改后的运行次数函数中，只保留最高阶项。
3、如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶

`n^2+n+100`，用`O(n^2)`表示。

### 常见时间复杂度
`O(1)` 常数阶
`O(n)` 线性阶
`O(n^2)` 平方阶
`O(logn)` 对数阶（2为底） 如下示例：
```java
int i=1;
while(i<=n){
    i=i*2;
}
```
`O(nlogn)` 线性对数阶
`O(n^3)` 立方阶
`O(2^n)` 指数阶
`O(n!)` 阶乘阶

时间复杂度从小到大依次是：
`O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)`
// 大多数情景下 对于`O(2^n)`、`O(n!)`、`O(n^n)` 称为非多项式量级，这种问题，叫做NP，非确定多项式问题。
对于`O(n^3)<O(2^n)<O(n!)<O(n^n)`，我们算法基本不需要考虑实现了
并且，对于`O(n^2)`，我们也需要考虑优化


还有其他的：如由两个变量表示的
`O(m+n)`
`O(m*n)`

## 空间复杂度
表示算法的存储空间和数据规模之间的关系。
就是程序运行所需要的空间。
经过分析，如果算法需要的辅助空间相对于数据量，所需的空间是常量，则表示原地工作。
示例：
```java
void print(int n){
    int i=0;
    int[] a=new int[n];
    for(i;i<n;++i){
        a[i]=i*i;
    }
    for(i=n-i;i>0;--i){
        print out a[i];
    }
}
```
上述示例中，使用的空间复杂度是`O(n)`。